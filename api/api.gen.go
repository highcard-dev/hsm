//go:build go1.22

// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// DownloadResponse defines model for DownloadResponse.
type DownloadResponse struct {
	// Url Signed download URL
	Url string `json:"url"`

	// Version Version of the download
	Version string `json:"version"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Error Error message
	Error string `json:"error"`
}

// GameSession defines model for GameSession.
type GameSession struct {
	// ExpiresAt Expiration time of the session
	ExpiresAt time.Time `json:"expiresAt"`

	// IdentityToken Identity token for authentication
	IdentityToken string `json:"identityToken"`

	// SessionToken Session token for the game server
	SessionToken string `json:"sessionToken"`
}

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	// Status Health status
	Status string `json:"status"`

	// Version Service version
	Version string `json:"version"`
}

// MessageResponse defines model for MessageResponse.
type MessageResponse struct {
	// Message Response message
	Message string `json:"message"`
}

// GetDownloadURLParams defines parameters for GetDownloadURL.
type GetDownloadURLParams struct {
	// Patchline Patchline to download (defaults to "release")
	Patchline *string `form:"patchline,omitempty" json:"patchline,omitempty"`
}

// DeleteSessionParams defines parameters for DeleteSession.
type DeleteSessionParams struct {
	// Token Session token (required in single-user mode)
	Token *string `form:"token,omitempty" json:"token,omitempty"`
}

// RefreshSessionParams defines parameters for RefreshSession.
type RefreshSessionParams struct {
	// Token Session token (required in single-user mode)
	Token *string `form:"token,omitempty" json:"token,omitempty"`
}

// GetDownloadURLPlainParams defines parameters for GetDownloadURLPlain.
type GetDownloadURLPlainParams struct {
	// Patchline Patchline to download (defaults to "release")
	Patchline *string `form:"patchline,omitempty" json:"patchline,omitempty"`
}

// GetVersionPlainParams defines parameters for GetVersionPlain.
type GetVersionPlainParams struct {
	// Patchline Patchline to check (defaults to "release")
	Patchline *string `form:"patchline,omitempty" json:"patchline,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get download URL
	// (GET /api/v1/download)
	GetDownloadURL(w http.ResponseWriter, r *http.Request, params GetDownloadURLParams)
	// Delete a session
	// (DELETE /api/v1/session)
	DeleteSession(w http.ResponseWriter, r *http.Request, params DeleteSessionParams)
	// Get current session
	// (GET /api/v1/session)
	GetSession(w http.ResponseWriter, r *http.Request)
	// Create a new session
	// (POST /api/v1/session)
	CreateSession(w http.ResponseWriter, r *http.Request)
	// Refresh a session
	// (POST /api/v1/session/refresh)
	RefreshSession(w http.ResponseWriter, r *http.Request, params RefreshSessionParams)
	// Get download URL (plain text)
	// (GET /download)
	GetDownloadURLPlain(w http.ResponseWriter, r *http.Request, params GetDownloadURLPlainParams)
	// Create session (env format)
	// (POST /game-session)
	CreateGameSessionEnv(w http.ResponseWriter, r *http.Request)
	// Health check
	// (GET /health)
	GetHealth(w http.ResponseWriter, r *http.Request)
	// Get version (plain text)
	// (GET /version)
	GetVersionPlain(w http.ResponseWriter, r *http.Request, params GetVersionPlainParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetDownloadURL operation middleware
func (siw *ServerInterfaceWrapper) GetDownloadURL(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDownloadURLParams

	// ------------- Optional query parameter "patchline" -------------

	err = runtime.BindQueryParameter("form", true, false, "patchline", r.URL.Query(), &params.Patchline)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "patchline", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDownloadURL(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteSession operation middleware
func (siw *ServerInterfaceWrapper) DeleteSession(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteSessionParams

	// ------------- Optional query parameter "token" -------------

	err = runtime.BindQueryParameter("form", true, false, "token", r.URL.Query(), &params.Token)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "token", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteSession(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetSession operation middleware
func (siw *ServerInterfaceWrapper) GetSession(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSession(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateSession operation middleware
func (siw *ServerInterfaceWrapper) CreateSession(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateSession(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RefreshSession operation middleware
func (siw *ServerInterfaceWrapper) RefreshSession(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params RefreshSessionParams

	// ------------- Optional query parameter "token" -------------

	err = runtime.BindQueryParameter("form", true, false, "token", r.URL.Query(), &params.Token)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "token", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RefreshSession(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDownloadURLPlain operation middleware
func (siw *ServerInterfaceWrapper) GetDownloadURLPlain(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDownloadURLPlainParams

	// ------------- Optional query parameter "patchline" -------------

	err = runtime.BindQueryParameter("form", true, false, "patchline", r.URL.Query(), &params.Patchline)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "patchline", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDownloadURLPlain(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateGameSessionEnv operation middleware
func (siw *ServerInterfaceWrapper) CreateGameSessionEnv(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateGameSessionEnv(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetHealth(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetVersionPlain operation middleware
func (siw *ServerInterfaceWrapper) GetVersionPlain(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetVersionPlainParams

	// ------------- Optional query parameter "patchline" -------------

	err = runtime.BindQueryParameter("form", true, false, "patchline", r.URL.Query(), &params.Patchline)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "patchline", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetVersionPlain(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/api/v1/download", wrapper.GetDownloadURL)
	m.HandleFunc("DELETE "+options.BaseURL+"/api/v1/session", wrapper.DeleteSession)
	m.HandleFunc("GET "+options.BaseURL+"/api/v1/session", wrapper.GetSession)
	m.HandleFunc("POST "+options.BaseURL+"/api/v1/session", wrapper.CreateSession)
	m.HandleFunc("POST "+options.BaseURL+"/api/v1/session/refresh", wrapper.RefreshSession)
	m.HandleFunc("GET "+options.BaseURL+"/download", wrapper.GetDownloadURLPlain)
	m.HandleFunc("POST "+options.BaseURL+"/game-session", wrapper.CreateGameSessionEnv)
	m.HandleFunc("GET "+options.BaseURL+"/health", wrapper.GetHealth)
	m.HandleFunc("GET "+options.BaseURL+"/version", wrapper.GetVersionPlain)

	return m
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xZX3PTOBD/KhrdPaQzbpIe3Itn7qHQHA0HpdMEGKbNdIS9iQW2ZCQ5kGPy3W/0z39i",
	"p2l7tIU7ntrY0u5q97e/Xa2/4ohnOWfAlMThVyyjBDJi/j3in1nKSXwGMudMgn6WC56DUBTMikKk+k8M",
	"MhI0V5QzHOIJXTCIUex2o9dnL3CA1SoHHGKpBGULvA7wEoQ0Gzb3v7EvEJ8jlUAppy1jHWABnwoqIMbh",
	"uTGmEjsrl/P3HyBSWuVICC62nwb067Y9ZhfKQEqygJ1WWCFd2p+RDCYg/aE3dH/JqQB5qDr061dE/0CK",
	"ZuD9Ip2oAM+5yIjCIY6Jgn29psvfNAamqFpN+Ufo8PrYvUZKv0dzLhApVKIfRkZ5l0xnwxaR7rA1idru",
	"Bcm08WIJYqczG/I3jxDUnNbl72MgqUq2h1sqogrZNtvuQ+611kKyPNWyE/NmdSM0T0AsaQTIL6jLO+gP",
	"+8PdTvCGXAXtlxae20/r8dsy0G+5NsL9urYZBhFRIahaTTSNWM1PgAgQh4VK9K/35tefHrLP305xsGHR",
	"87dTZDc56LSAaEhKa7bSKpMTpXK81oZQNuftwx6ejg0QM8LIgrIFOl4pkjZA6RNLIsIqFtP+V1SZsB1P",
	"XqJ9v3NiN73UAkGgw9NxLVI+xOsA8xwYySkO8aP+sP8IBzgnKjEOGpCcDpYHg5Lpwq94AaorVKoQTNr0",
	"b7OsMdiptgmMcqKiJKVMR1WjwThwHOMQPwPl+d0SdE4EyUCBkDg839R86uUgxSudvRjmpEiV1E8vsIAU",
	"iIQLvKdzVW/7VIDQ6cKIiVbdGltn7BmNEBx6AR0InGkIWpwal/02HOo/EWcKmPEUyfPUAWTwQdpMrHT8",
	"KmCOQ/zLoCp2A1fpBq0yZ/DTPP9RvZitA/z7N9TfrEodysdMgWAk9QC1JcZkW5FlRKxsOFsVlyx0KEvb",
	"8Uxv8WCTVSWKIQXVwQxH5rmFW1QIAUz55OijMUOSskUK+4UEgTIeQ4AcTUiXtyb8qARWvwVCq2FSVrIr",
	"MdgsJz1PSYi2LdkGQOUKRxWY+wTaJkd3hNqf0YYk1lB7fJ9Qe0JiE0SQCvWso6/2szHw4P4MfM10MeCC",
	"/m29890looU0IrX+zCeix/lsHezmd59wrjLJktT1y1pBhBiZcPSyIlW0Cg3iLF3tddF+lW53hvR6q9vh",
	"x6dNMnlwED0ePr4/5Se8Fs6CORQf3KcBCpEloSl5n0JXVneUlg363wLqnMsOVD8VQHQZIYjB5waeW+i0",
	"Sx8eoJ6GI2NP/JPlNlnOBsqF9CpQtDuOgYC5AGkuA92AObMLNGQYgi9UKt2p14HzjdoPp+j/0n9cE/Qu",
	"Pj+7jx+icHxnxOBSakf/o1nh3992JcpTQhlS8EXtuN+e6oU//iVXn3RgDt0M66akW9xfby36NrdT1Ksi",
	"t7f9qqopf792Ub1pf2EGIsLBiCrDIQmkKQK2pIKzTLc0bnra3YrUKHPElvjWAapmfsfvpocvRpeT0dmb",
	"0dnlZDSZjF+dXE5f/TU6+ePCFojLBARc4AvWXDs+Gp1Mx9N35WI/Di3Xd2BqV2ujfQJs6b3QSai3hsbu",
	"NuZOUeeaFA+GXnXOva2sZEe81+KkpD4nbszeygm9Gf12UZOdMd9lh7sx/e5Egp1MU4n8YLs+wcXh+azu",
	"TTcWjxKIPtbc505ivVebgu90X6qTVpU+28nm7rPQzZncWPzfoHH/aaz67vAARO4jdg0Ob8Kp+SngfKY9",
	"ZXV1xfAFj0pbcGA/NeIBXs/W/wQAAP//9efUEbMcAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
